// lib/featureCache.ts
import { AppConfigurationClient } from "@azure/app-configuration";

type CachedEntry = {
  value: unknown;
  etag?: string;
  expiresAt: number;
};

const CONNECTION_STRING = "Endpoint=https://contactcentre-dev-d190-appcfg.azconfig.io;Id=0;Secret=0";
if (!CONNECTION_STRING) {
  throw new Error("Missing AZURE_APP_CONFIG_CONNECTION env var");
}

const client = new AppConfigurationClient(CONNECTION_STRING);

let CACHE_TTL_MS = 300_000; // default 300 seconds

const cache = new Map<string, CachedEntry>();
const inflight = new Map<string, Promise<unknown>>();

async function _fetchFromAppConfig(
  key: string,
): Promise<{ value: unknown; etag?: string }> {
  const setting = await client.getConfigurationSetting({ key });
  const raw = setting.value;
  let parsed: unknown;
  try {
    parsed = raw ? JSON.parse(raw) : raw;
  } catch {
    parsed = raw;
  }
  return { value: parsed, etag: setting.etag };
}

async function getFlag(key: string): Promise<unknown> {
  const now = Date.now();
  const cached = cache.get(key);
  if (cached && cached.expiresAt > now) {
    return cached.value;
  }

  // Deduplicate concurrent fetches
  if (inflight.has(key)) {
    return inflight.get(key)!;
  }

  const p = (async () => {
    try {
      const { value, etag } = await _fetchFromAppConfig(key);

      const existing = cache.get(key);
      if (existing && existing.etag === etag) {
        existing.expiresAt = Date.now() + CACHE_TTL_MS;
        return existing.value;
      }

      cache.set(key, { value, etag, expiresAt: Date.now() + CACHE_TTL_MS });
      return value;
    } finally {
      inflight.delete(key);
    }
  })();

  inflight.set(key, p);
  return p;
}

export async function featureFlagEnabled(featureFlag: string): Promise<boolean> {
  const key = `.appconfig.featureflag/${featureFlag}`;
  const flag = await getFlag(key);

  if (flag && typeof flag === "object" && "enabled" in flag) {
    const f = flag as { enabled?: unknown };
    return Boolean(f.enabled);
  }

  return false;
}
