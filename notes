// lib/featureCache.ts
import { AppConfigurationClient } from "@azure/app-configuration";

type CachedEntry = {
  value: unknown;
  etag?: string;
  expiresAt: number;
};

const CONNECTION_STRING = process.env.AZURE_APP_CONFIG_CONNECTION;
if (!CONNECTION_STRING) {
  throw new Error("Missing AZURE_APP_CONFIG_CONNECTION env var");
}

const client = new AppConfigurationClient(CONNECTION_STRING);

// Configuration
let CACHE_TTL_MS = 60_000; // default 60 seconds

// Internal state held in module closure
const cache = new Map<string, CachedEntry>(); // key -> { value, etag, expiresAt }
const inflight = new Map<string, Promise<unknown>>(); // key -> Promise resolving to value

async function _fetchFromAppConfig(
  key: string,
): Promise<{ value: unknown; etag?: string }> {
  const setting = await client.getConfigurationSetting({ key });
  const raw = setting.value;
  let parsed: unknown;
  try {
    parsed = raw ? JSON.parse(raw) : raw;
  } catch {
    parsed = raw;
  }
  return { value: parsed, etag: setting.etag };
}

/**
 * Get a flag value from cache or App Configuration.
 * @param key - full App Configuration key, e.g. '.appconfig.featureflag/my-flag'
 * @returns parsed flag value
 */
export async function getFlag(key: string): Promise<unknown> {
  const now = Date.now();
  const cached = cache.get(key);
  if (cached && cached.expiresAt > now) {
    return cached.value;
  }

  // Deduplicate concurrent fetches
  if (inflight.has(key)) {
    return inflight.get(key)!;
  }

  const p = (async () => {
    try {
      const { value, etag } = await _fetchFromAppConfig(key);

      // If cached and etag unchanged, just extend TTL
      const existing = cache.get(key);
      if (existing && existing.etag === etag) {
        existing.expiresAt = Date.now() + CACHE_TTL_MS;
        return existing.value;
      }

      // Otherwise update cache
      cache.set(key, { value, etag, expiresAt: Date.now() + CACHE_TTL_MS });
      return value;
    } finally {
      inflight.delete(key);
    }
  })();

  inflight.set(key, p);
  return p;
}

/**
 * Force refresh a key from App Configuration and update cache immediately.
 * @param key
 */
export async function refreshFlag(key: string): Promise<unknown> {
  // Deduplicate refreshes too
  if (inflight.has(key)) return inflight.get(key)!;

  const p = (async () => {
    try {
      const { value, etag } = await _fetchFromAppConfig(key);
      cache.set(key, { value, etag, expiresAt: Date.now() + CACHE_TTL_MS });
      return value;
    } finally {
      inflight.delete(key);
    }
  })();

  inflight.set(key, p);
  return p;
}

/**
 * Invalidate a cached key so next getFlag will fetch from App Configuration.
 * @param key
 */
export function invalidateFlag(key: string): void {
  cache.delete(key);
}

/**
 * Get all cached keys and values (useful for debugging)
 */
export function getAllCached(): Record<string, CachedEntry> {
  const out: Record<string, CachedEntry> = {};
  for (const [k, v] of cache.entries()) {
    out[k] = { value: v.value, etag: v.etag, expiresAt: v.expiresAt };
  }
  return out;
}

/**
 * Adjust TTL at runtime
 * @param ms
 */
export function setCacheTTL(ms: number): void {
  CACHE_TTL_MS = Number(ms) || CACHE_TTL_MS;
}

export async function isEnabled(featureFlag: string): Promise<boolean> {
  const key = `.appconfig.featureflag/${featureFlag}`;
  const flag = await getFlag(key);

  if (flag && typeof flag === "object" && "enabled" in flag) {
    const f = flag as { enabled?: unknown };
    return Boolean(f.enabled);
  }

  return false;
}

// Export default convenience that exposes getFlag
const defaultExport = {
  getFlag,
  refreshFlag,
  invalidateFlag,
  getAllCached,
  setCacheTTL,
  isEnabled,
};
export default defaultExport;
